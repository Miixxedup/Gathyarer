import argparse
import datetime
import os
import re
import time
from shutil import rmtree

__logo__ =f''' 
   ___      _   _                         
  / __|__ _| |_| |_ _  _ __ _ _ _ ___ _ _ 
 | (_ / _` |  _| ' \ || / _` | '_/ -_) '_|
  \___\__,_|\__|_||_\_, \__,_|_| \___|_|  
                    |__/                  
        By https://github.com/miixxedup
        '''

# Crawls to files, finds all .yara files and puts them into a single file
class Gathyarer:
    def __init__(self, start_folder,add_timestamp,debug):
        #Initialize vars
        self.root_folder = start_folder
        self.file_counter = 0
        self.already_seen = []
        self.skipped_list = []

        if (add_timestamp):
            self.ts = f"{round(time.time())}-"
        else:
            self.ts = ""
        self.mode_debug = debug
        self.result_folder_name = f"result-{self.ts}agg"
        self.result_yara_file = f"YARA-{self.ts}agg"

# Build a general file structure and remove old structures
    def GenerateStructure(self):
        print(__logo__)
        dirs = os.listdir()
        for o in os.listdir():
             if o.endswith("-agg"):
                delete = input(f"[???] PREVIOUSLY GENERATED FOLDER {o} FOUND, DELETE IT AND ITS CONTENTS?(Y/N): ")
                if delete == 'Y':
                    rmtree(o)
                else:
                    print("[!!!] Exiting as there is already an exiting folder and file.")
                    exit()
                    
        # Create the new folders and files
        os.mkdir(self.result_folder_name)
        os.mkdir(f"{self.result_folder_name}/collected")
        # Create a starting ruleset
        with open(f'{self.result_folder_name}/{self.result_yara_file}.yara',"w+") as y:
            y.write(
f'''
/*
{__logo__}
Collection off all .yara files found in root_dir, generated at {datetime.datetime.now()}
*/\n''')

    # Static method used as 'repl' in re.sub(org,rpl,target) only accepts a functions with 1 arg. This makes it ugly in a class structure but w/e :)
    @staticmethod
    def my_replace(match):
        m = match.group()
        ts = str(time.time()).split('.')[1]
        return f"\nrule gathyarer_{ts}_{m.split('rule')[1].strip()}"

    # Methods which need to be executing DURING the execution of the program or are best executed DURING
    # Should return false is a statement is not satisfied including a print message before
    def DuringProcessFixing(self,data, f_name):
        # Try to exclude only include files.
        if "strings" and "condition" not in data:
            print(f"[!!!] {f_name}: Looks like include only file or invalid Yara, skipping ... ")
            self.skipped_list.append(f_name)
            return False

        # Fix all rulenames to never collide
        data_new = re.sub("\s*rule\s.+\n*(?=\{)", self.my_replace, data)
        return data_new
    

    # Methods which need to be executed AFTER the execution of the program or are best executed AFTER
    # Should return false is a statement is not satisfied including a print message before
    # Not used for now
    def PostProcessFixing(self):
        pass

    # Prepare files, including:
    # Try to exclude 'include only' files
    # Skip all current generated folders (generated by this program)
    def PrepareFiles(self, f):
        # Test for include only
        with open(f,"r") as y:
            data = y.read()
            data = self.DuringProcessFixing(data, f)
            if not data:
                return
        # Prevent recursion
        if self.result_folder_name in f:
            print("Skip file to avoid recursive loop")
            return
        # Paste new data into to local file structure.
        with open(f"{self.result_folder_name}/collected/{self.file_counter}.yara", 'w+') as new_file:
            new_file.write(data)
        self.rule_name_counter = 0

        # Append the new 'main' yara-file with include files
        with open(f"{self.result_folder_name}/{self.result_yara_file}.yara","a") as y:
            y.write(f"include \"collected/{self.file_counter}.yara\"\n")
            self.rule_name_counter = 0

        self.file_counter+=1
        self.rule_name_counter = 0

    # Start looping and find all files
    def Start(self):
        for root, dirs, files in os.walk(self.root_folder):
            for filename in files:
                self.FindFiles(os.path.join(root, filename))
        print("\n[:-)] Done searching and collecting")
        if self.mode_debug:
            print(f"Skipped items: {self.skipped_list}")
    
    # FindFiles will filter files matching the .ext
    def FindFiles(self, f, ext=[".yar",".yara"]):
        if self.mode_debug:
            print(f" ----- file:{f} ----- ")
        for e in ext:
            if f.endswith(e):
                print(f"[.] Found possible Yara file at {f}")
                self.PrepareFiles(f)
    
parser = argparse.ArgumentParser()
parser.add_argument("p", help="Supply a file path to start from")
parser.add_argument("-ts", action='store_true',help= "Appends timestamps during foldergeneration for foldernames and resulting .yara file")
parser.add_argument("-d",action='store_true', default=False, help="Returns debug information")
args = parser.parse_args()

g = Gathyarer(args.p, args.ts, args.d)
g.GenerateStructure()
g.Start()
